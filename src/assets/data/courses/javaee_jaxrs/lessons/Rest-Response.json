{"courseCode":"javaee_jaxrs","courseName":"Developing REST APIs with JAX-RS","description":"We've looked at requests so far, and understood resource URIs and HTTP methods. Let's switch to responses now.","permalinkName":"Rest-Response","title":"REST Response","unitSlNo":"1.11","youtube":"ZyuPCYB-n5o","duration":993,"slNo":11,"prev":"/courses/javaee_jaxrs/lessons/Idempotence-In-HTTP-Methods","next":"/courses/javaee_jaxrs/lessons/HATEOAS","content":"<p>We&#39;ve looked at requests so far, and understood resource URIs and HTTP methods. Let&#39;s switch to responses now.</p>\n<h2 id=\"from-requests-to-responses\">From requests to responses</h2>\n<p>We&#39;ve learned where to make requests (resource URIs) and how to make requests (HTTP methods). Time to look at responses now. When a request comes in, what should the REST web service respond with? Knowing what the client will get back from the server is an important part of the API, because the client needs to write code to handle the response.</p>\n<p>If it were a web application, we know  the response is usually an HTML page. With styling, formatting and also, of course, the actual data in a presentable format. But when it comes to RESTful web services, you don&#39;t need to do all the styling and formatting anymore. You just need to send the actual data. How do you send it?</p>\n<p>We discussed about various standard formats that responses can be sent in, like XML and JSON. JSON has been growing in popularity, because it is much more compact and less verbose when  compared to XML, especially when large data is involved. Also, more often than not, a client to a RESTful API is client side Javascript code, and sending back data in JSON means it can easily convert it to a Javascript object. Considering these advantages, we&#39;ll choose JSON as response for our social media application in this course. However, note that you do not typically need to settle for just one format. You can write APIs to support multiple response formats, and we will implement one such API endpoint later in this course to illustrate that.</p>\n<h2 id=\"formats\">Formats</h2>\n<p>Let&#39;s say our Message entity class has these four member variables: the id, the text of the message, when it was created and who created it.</p>\n<pre><code class=\"lang-java\">public class MessageEntity {\n    private long id;\n    private String message;\n    private Date created;\n    private String author;\n...\n}\n</code></pre>\n<p>When a GET request is made for a specific message, say message ID 10, the JSON that you would return would look something like this:</p>\n<pre><code>{\n    &quot;id&quot;:&quot;10&quot;,\n    &quot;message&quot;:&quot;Hello world&quot;,\n    &quot;created&quot;:&quot;2014-06-01T18:06:36.902&quot;,\n    &quot;author&quot;:&quot;koushik&quot;\n}\n</code></pre><p>But the response doesn&#39;t <em>have</em> to be JSON. You could return XML as well, if the client asks for it in XML format.  We haven&#39;t yet covered how a client can <em>ask</em> for a specific format. We&#39;ll be looking at that later. But yes, a client can say &quot;I need a JSON response&quot; or &quot;Give me an XML response&quot;.  Here is a possible XML response for the same message ID 10.</p>\n<pre><code>&lt;messageEntity&gt;\n    &lt;id&gt;10&lt;/id&gt;\n    &lt;message&gt;Hello world&lt;/message&gt;\n    &lt;created&gt;2014-06-01T18:06:36.902&lt;/created&gt;\n    &lt;author&gt;koushik&lt;/author&gt;\n&lt;/messageEntity&gt;\n</code></pre><p>Clearly the JSON response and the XML response are different. But they represent the same resource: message ID 10. So, in other words both these responses are different representations of the same resource. This is a very important thing to remember. When you make REST API calls you are sending or receiving <em>representations</em> of the resource. Different representations could have different formats, even though the underlying resource is the same. This is actually how REST gets its name. Representational State Transfer.  You are transferring the representational state.</p>\n<blockquote>\n<p>When you make REST API calls you are sending or receiving <em>representations</em> of the resource.</p>\n</blockquote>\n<h2 id=\"message-headers\">Message Headers</h2>\n<p>Ok, so it&#39;s great that a REST web service can return data in XML or JSON. But that brings up a problem. How does the client know what format the response is in? The client can of course request data in a particular format, but there&#39;s no guarantee that the service responds in that format. Say, a client request asks for XML. But if the REST service knows only JSON, it does return JSON ignoring the client&#39;s preference for XML. How does the client know the format then?</p>\n<p>The answer is using HTTP headers. The HTTP protocol has a concept of request and response headers. Every HTTP request or response has a body, which is the message itself, and certain header values that contain metadata about the message. The header data could be stuff like the content length and date. One such possible header is <code>Content-Type</code>. The response could contain the Content-Type header with the value for JSON or XML. There are special values for JSON and XML, and we&#39;ll learn more about that when we implement this, but for now, know that the type of content is being sent back as a response header. The client can then examine this header value and then parse the response body content accordingly.</p>\n<h2 id=\"status-codes\">Status codes</h2>\n<p>Think about error messages in a web application. Whens something goes wrong, the application typically returns a page with an error message, maybe in bold red text. Even if it isn&#39;t in red, the message itself would give the user an idea that it&#39;s an error. But in the case of REST APIs, since the consumer is not a human, we need to provide some set of codes to the consumer to help them identify error scenarios. </p>\n<p>HTTP specification requires the very first line of any response to be a <em>status line</em>. This line will have a numerical code and a short phrase explaining what the code means. This is not just for errors. Every HTTP response needs to have this line. If the response is successful, the very first line of the response will be:\n<code>200 OK</code></p>\n<p>Let&#39;s take the familiar 404 error code. If a request is made on a URI, for example <code>/messages/101</code> and there is no message available with ID 101, the first line of the response should be:\n<code>404 Not Found</code></p>\n<p>Again, the code <code>404</code> is for the client code to read and act. The phrase <code>Not Found</code> is an aid to the programmer, in case they forget what the code means. Not that any programmer would ever forget what <code>404</code> means. I mean, come on!</p>\n<p>There are a bunch of codes that are important for us to remember and use when developing a REST API. The error codes start from 100 and go up to 599. Not all of them are valid error codes though, so you don&#39;t have 500 different possible error codes. There are 5 classes of status codes and the first digit indicates what class the code belongs to: 1 to 5.</p>\n<h2 id=\"1xx-codes-informational\">1XX Codes - Informational</h2>\n<p>The codes starting with 1XX are informational, like acknowledgement responses. We&#39;ll not be using this set of codes in this course.</p>\n<h2 id=\"2xx-codes-success\">2XX Codes - Success</h2>\n<p>The codes starting with 2XX are success codes. This indicates that the server received the request from the client and processed it successfully. Some examples:</p>\n<h3 id=\"200-ok\">200 OK</h3>\n<p>Indicates successful response. You&#39;d return this for any request that you can successfully respond to.</p>\n<h3 id=\"201-created\">201 Created</h3>\n<p>Indicates successful resource creation. Say you get a POST request for a collection URI like <code>/messages</code> and you successfully create a new message. You could return <code>200 OK</code> to indicate success, but a better response code would be <code>201 Created</code>.</p>\n<h3 id=\"204-no-content\">204 No Content</h3>\n<p>Sometimes the server receives requests that need it to do something, but it doesn&#39;t need to return any content back. Like DELETE requests, for example. In this case, you could either return <code>200 OK</code> with no response content. Or return <code>204 No Content</code>, which makes it obvious that the server really intends to send nothing back.</p>\n<h2 id=\"3xx-codes-redirection\">3XX Codes - Redirection</h2>\n<p>The server sends these codes to ask the client to do further action to complete the request. For example, it could be a redirect, asking the client to send the request somewhere else. </p>\n<h3 id=\"302-found-and-307-temporary-redirect\">302 Found and 307 Temporary Redirect</h3>\n<p>One of these two error codes are returned by the server if it wants the client to request elsewhere. It&#39;s a redirect.</p>\n<h3 id=\"304-not-modified\">304 Not Modified</h3>\n<p>When a client tries to get a resource that it has already got before, the server can send this status code to say &quot;I&#39;ve already given you this resource a little while back, and nothing has changed since then.&quot;</p>\n<h2 id=\"4xx-codes-client-error\">4XX Codes - Client error</h2>\n<p>These error codes are returned if the client makes an error in the request. The request syntax could have been incorrect, or the client is requesting something that it&#39;s not supposed to see.</p>\n<h3 id=\"400-bad-request\">400 Bad Request</h3>\n<p>This is a client error. The server is not able to understand the request</p>\n<h3 id=\"401-unauthorized\">401 Unauthorized</h3>\n<p>The request needs the client to <em>sign in</em> or authorize themselves.</p>\n<h3 id=\"403-forbidden\">403 Forbidden</h3>\n<p>The client may have authorized, but they are still not allowed to make the request. (Maybe they don&#39;t have the right access rights).</p>\n<h3 id=\"404-not-found\">404 Not Found</h3>\n<p>No description required. :)</p>\n<h3 id=\"415-unsupported-media-type\">415 Unsupported Media Type</h3>\n<p>The client is speaking in a language that the server cannot understand</p>\n<h2 id=\"5xx-codes-server-error\">5XX Codes - Server error</h2>\n<p>The 4XX codes are when the client screws up when sending the request. The 5XX codes are when the server screws up when sending the response. It&#39;s basically the server saying, Ok, I got your request, and it looked like a valid one, but something went wrong when I tried to process it.</p>\n<h3 id=\"500-internal-server-error\">500 Internal Server Error</h3>\n<p>This is a generic error code. The server gets a request. The resource exists (or you&#39;d send a 404 instead) but something went wrong when processing the request. In such cases, the standard practice is to send the error code 500, along with error details in the body of the request.</p>\n<p>There are a bunch of other codes, but these are the important ones to remember. We&#39;ll look at more when we start implementing some of these APIs. But let me remind you again. These error codes are for you, as a web service developer to use. The clients know what it means when they see one of these error codes. So, it&#39;s up to you to send the right error codes when these events happen. For example, let&#39;s say you get a runtime exception when processing a request. You need to send back error code 500. Because it means server error. And the client will then know what&#39;s happened.</p>\n<h2 id=\"scenarios\">Scenarios</h2>\n<p>Let&#39;s look at the same CRUD use cases we saw in the previous tutorial, and identify what the status codes should be for the message resource</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th style=\"text-align:center\">URI</th>\n<th>Method</th>\n<th>Success / Failure</th>\n<th>Status code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>GET</td>\n<td>Success</td>\n<td>200</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Delete message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>DELETE</td>\n<td>Success</td>\n<td>200 or 204 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Edit message</td>\n<td style=\"text-align:center\"><code>/messages/{messageId}</code></td>\n<td>PUT</td>\n<td>Success</td>\n<td>200 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Not found</td>\n<td>404</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n<tr>\n<td>Create message</td>\n<td style=\"text-align:center\"><code>/messages</code></td>\n<td>POST</td>\n<td>Success</td>\n<td>201 </td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Wrong format / data</td>\n<td>400 or 415</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:center\"></td>\n<td></td>\n<td>Failure</td>\n<td>500</td>\n</tr>\n</tbody>\n</table>\n<p>Hope this gives you a better idea of the status codes to be returned. Responses for other resources would mostly follow the same pattern. Again, this is just a small subset of the HTTP status codes, and we&#39;ll look at more when we start implementing APIs.</p>\n<p>In this tutorial, we learnt about:</p>\n<ol>\n<li>Resource representations</li>\n<li>Message headers in HTTP and</li>\n<li>HTTP status codes</li>\n</ol>\n","type":"video","durationText":"16 minutes","topic":"javaee","unit":{"lessons":[{"title":"Introduction","description":"Welcome to this course. This tutorial introduces you to REST APIs and explains some basic concepts.","permalinkName":"Introduction","type":"video","slNo":1,"durationText":"16 minutes"},{"title":"REST and HTTP","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"REST-and-HTTP","type":"video","slNo":2,"durationText":"14 minutes"},{"title":"REST and HTTP","description":"In this tutorial, we will learn some HTTP concepts that have influenced REST.","permalinkName":"HTTP-Concepts","type":"quiz","slNo":3,"durationText":"5 questions"},{"title":"Designing Resource URIs","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Designing-Resource-URIs","type":"video","slNo":4,"durationText":"18 minutes"},{"title":"Designing Resource URIs","description":"In this tutorial, we’ll start designing a sample RESTful API for our sample social media application. And through the process, we’ll understand how RESTful URIs are designed.","permalinkName":"Resource-URIs-Quiz","type":"quiz","slNo":5,"durationText":"3 questions"},{"title":"RESTful URI types","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"RESTful-URI-types","type":"video","slNo":6,"durationText":"7 minutes"},{"title":"RESTful URI types","description":"You can think of RESTful URIs as belonging to two types: instance resource URIs and collection resource URIs. Let's understand what they mean.","permalinkName":"URI-types","type":"quiz","slNo":7,"durationText":"4 questions"},{"title":"HTTP Methods","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods","type":"video","slNo":8,"durationText":"11 minutes"},{"title":"HTTP Methods","description":"Now that we've identified some important resource URIs, let's work on the operations that can be performed and the data that's exchanged.","permalinkName":"HTTP-Methods-Quiz","type":"quiz","slNo":9,"durationText":"3 questions"},{"title":"Idempotence In HTTP Methods","description":"Idempotence. Yes, that's a word. And it's an important property of HTTP methods according to the specifications.","permalinkName":"Idempotence-In-HTTP-Methods","type":"video","slNo":10,"durationText":"12 minutes"},{"title":"REST Response","description":"We've looked at requests so far, and understood resource URIs and HTTP methods. Let's switch to responses now.","permalinkName":"Rest-Response","type":"video","slNo":11,"durationText":"16 minutes"},{"title":"HATEOAS","description":"In this tutorial, we'll learn about an important concept relating to REST APIs: HATEOAS\n","permalinkName":"HATEOAS","type":"video","slNo":12,"durationText":"14 minutes"},{"title":"The Richardson Maturity Model","description":"In this tutorial, we'll learn about the Richardson Maturity Model, a way for REST APIs to be classified, and the \"RESTfulness\" of an API determined.","permalinkName":"The-Richardson-Maturity-Model","type":"video","slNo":13,"durationText":"8 minutes"}]}}